## Communicating using the Asynchronous messaging pattern

### Overview of messaging

- A message consists of a header and a message body.
- Header
    - The header is a collection of name-value pairs, metadata that describes the data being sent.
    - The header can also contain messageId, generated by either the sender or messaging infrastructure.
    - The header can also contain an optional return address, which specifies the message channel that a reply should be written to.
- Body
    - The message body is the data being sent.
    - There are several types of messages.
        - `Document:` A generic message that contains only data.
        - `Command:` A message that specifies the operation to invoke and its parameters.
        - `Event:` A message indicating an event, which represents a state change of a domain object like Order, Customer etc.

### Overview of messaging channels

- Messages are exchanged over channels.
- There are two types of message channels.
    - `A point-to-point channel:` Delivers a message to exactly one of the consumers that is reading from the channel.
        - For ex, a `command message`.
    - `A publish-subscribe channel:` Delivers each message to all the attached consumers.
        - For ex, an `event message`.

<img src="images/asynchronous_messaging.png" height=300 width=500>

#### Asynchronous request/response

- Asynchronous messages are commonly used for one way notifications, where sender sends a message and receiver(s) consume.
- Asynchronous messages are also used for request/response style of communication.
    - The client sends a command message, which specifies the message identifier, operation to perform, and parameters.
    - The command message has a reply channel information in the header.
    - The server writes the reply message, which contains a correlation id that has the same value as message identifier to the reply channel.
    - The client uses the correlation id to match the reply message with the request.

<img src="images/async_req_res.png" height=300 width=500>

## API's specification for a messaging-based service API

- The specification for a service’s asynchronous API must specify
    - Names of the message channels
    - Message types(command, document or event)

<img src="images/async_api_spec.png" height=300 width=400>

## Using a message broker

- A message broker is an intermediary through which all messages flow.
- Benefits
    - The sender doesn’t need to know the network location of the consumer.
    - A message broker buffers messages until the consumer is able to process them.
    - Flexible interaction styles
        - point-to-point
        - publish/subscribe

- Examples of popular open source message brokers:
    - ActiveMQ
    - RabbitMQ
    - Apache Kafka

### Selecting message broker

- The following factors need to be considered while selecting a message broker.
    - `Supported programming languages:` Does message broker supports a variety of programming languages?
    - `Supported messaging standards:`  Does broker follows standards such as AMQP and STOMP, or proprietary?.
    - `Messaging ordering:` Does message broker which preservers order?.
    - `Delivery guarantees:` what delivery guarantees are provided?
    - `Persistence:` Does message broker persist data to disk and able to survive broker crashes?.
    - `Durability:` If a consumer reconnects to the message broker, does it receive the messages that were sent while disconnected.
    - `Scalability:` how scalable is the message broker?
    - `Latency:` what is the end-to-end latency?
    - `Competing consumers:` Does the message broker support competing consumers?

### Drawbacks

- `Potential performance bottleneck:` Fortunately, many modern message brokers are highly scalable.
- `Potential single point of failure:` It should be highly available, otherwise system reliability will be impacted.
- `Additional operational complexity:` It is another system that should be installed, configured and operated.

## Competing receivers and message ordering

- Preserving the order of messages is challenging when multiple instances of a same service compete.
    - `Problem`
        - For ex, there are three instances of a service reading from the same point-to-point channel.
        - A sender publishes Order Created, Order Updated, and Order Cancelled event messages sequentially.
        - The order of these events may go wrong due to network issues or due to any other reason.
    - `Solution`
        - A common solution is to use sharded channels(apache kafka).
        - A sharded channel consists of two or more shards, each of which behaves like a channel.
            - The sender specifies a shard key in the message’s header.
            - The message broker uses a shard key to assign the message to a particular shard/partition.
        - The messaging broker groups together multiple instances of a receiver(treats them as the same logical receiver).
            - For example, apache kafka uses the term consumer group.
            - The message broker assigns each shard to a single receiver.

<img src="images/competing_receivers.png" height=300 width=400>

## Handling duplicate messages

- A failure of a client, network, or message broker can result in a message being delivered multiple times.
- Duplicate messages can be handled in the following ways
    - `Idempotent message handlers:`
        - Application logic has to be idempotent.
        - If message is received multiple times, it will have no effect.
        - It is not practically possible to write idempotent message handlers all times.
    - `Tracking messages`
        - Consumer should track messages that it has processed and discard any duplicates.
        - There are two ways to handle this.
            - Store the message id of each message that is consumed in a new database table.
            - To record message ids in an application table instead of a dedicated table.
                - This approach is particularly useful when using a NoSQL database that has a limited transaction model.

<img src="images/discard_duplicates.png" height=300 width=400>

## _Transactional Messaging_

- A service often needs to publish messages as part of a transaction along with updating the database.
- A service might update the database and then crash without sending to the message broker.
- Distributed transaction that spans the database and the message broker are not supported by modern message brokers.

### _Using a database table as a message queue_

- One solution to the transaction messaging is Transactional outbox.
- This pattern uses a database table as a temporary message queue.
- As part of the db transaction that does CUD on business objects, the service inserts them into `OUTBOX` table.
- Atomicity is guaranteed because this is a local ACID transaction.
- The Outbox table acts as a temporary storage.
- The MessageRelay is a component(app) that reads messages from outbox table and publishes them to message broker.
- This approach works with NoSQL DBs also.

<img src="images/transactional_outbox.png" height=300 width=400>

### _Publishing Events_

- There are two ways to publish events.

#### _Polling publisher pattern_

- MessageRelay component polls the OUTBOX table for unpublished messages.

```SELECT * FROM OUTBOX ORDERED BY ... ASC```

- MessageRelay publishes the messages to the message broker.
- MessageRelay deletes those messages from the OUTBOX table.

```
BEGIN
DELETE FROM OUTBOX WHERE ID in (....)
COMMIT
```
- Drawbacks
    - Frequently polling the database can be expensive.
    - All NoSQL databases may not support this.

#### _Transaction log tailing pattern_

- A sophisticated solution is for MessageRelay to tail the database transaction log (also called the commit log).
- Every committed update made is represented as an entry in the database’s transaction log.
- A transaction log miner can read the transaction log and publish each change as a message to the message broker.
    - The Transaction Log Miner reads the transaction log entries.
    - It converts each relevant log entry corresponding to an inserted message into a message.
    - It publishes that message to the message broker.
    - This works with both SQL and NOSQL.

<img src="images/transaction_log.png" height=300 width=400>

- Few examples of transaction log miners are
    - `Debezium (http://debezium.io):` - An open source project that publishes messages to apache kafka.
    - `LinkedIn Databus:` - An open source project that mines the Oracle transaction log and publishes the changes as events.
    - `DynamoDB streams:` - DynamoDB streams contain the time-ordered sequence of changes (creates, updates, and deletes)
      made to the items in a DynamoDB table in the last 24 hours.
    - `Eventuate Tram:` - An open source transaction messaging library that uses MySQL binlog protocol, Postgres WAL,
      or polling to read changes made to an OUTBOX table and publish them to Apache Kafka.

    